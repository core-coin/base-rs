//! # base-ylm-macro
//!
//! This crate provides the [`ylm!`] procedural macro, which parses Ylem
//! syntax to generate types that implement [`base-ylm-types`] traits.
//!
//! Refer to the [macro's documentation](ylm!) for more information.
//!
//! [`base-ylm-types`]: https://docs.rs/base-ylm-types

#![warn(missing_copy_implementations, missing_debug_implementations, missing_docs, rustdoc::all)]
#![cfg_attr(not(test), warn(unused_crate_dependencies))]
#![deny(unused_must_use, rust_2018_idioms)]
#![cfg_attr(docsrs, feature(doc_cfg, doc_auto_cfg))]

#[macro_use]
extern crate proc_macro_error;
extern crate syn_ylem as ast;

use base_ylm_macro_input::{YlmAttrs, YlmInput, YlmInputExpander, YlmInputKind};
use proc_macro::TokenStream;
use quote::quote;
use syn::parse_macro_input;

mod expand;
mod utils;

#[cfg(feature = "json")]
mod verbatim;

/// Generate types that implement [`base-ylm-types`] traits, which can be used
/// for type-safe [ABI] and [EIP-712] serialization to interface with Core
/// smart contracts.
///
/// [ABI]: https://docs.soliditylang.org/en/latest/abi-spec.html
/// [EIP-712]: https://eips.ethereum.org/EIPS/eip-712
///
/// # Examples
///
/// > Note: the following example code blocks cannot be tested here because the
/// > generated code references [`base-ylm-types`], so they are [tested in that
/// > crate][tests] and included with [`include_str!`] in this doc instead.
///
/// [tests]: https://github.com/core-coin/base-rs/tree/main/crates/ylm-types/tests/doctests
/// [`base-ylm-types`]: https://docs.rs/base-ylm-types
///
/// There are two main ways to use this macro:
/// - you can [write Ylem code](#solidity), or provide a path to a Ylem file,
/// - if you enable the `json` feature, you can provide [an ABI, or a path to one, in JSON
///   format](#json-abi).
///
/// Note:
/// - relative file system paths are rooted at the `CARGO_MANIFEST_DIR` environment variable
/// - no casing convention is enforced for any identifier,
/// - unnamed arguments will be given a name based on their index in the list, e.g. `_0`, `_1`...
/// - a current limitation for certain items is that custom types, like structs, must be defined in
///   the same macro scope, otherwise a signature cannot be generated at compile time. You can bring
///   them in scope with a [Ylem type alias](#udvt-and-type-aliases).
///
/// ## Ylem
///
/// This macro uses [`syn-ylem`][ast] to parse Ylem-like syntax. See
/// [its documentation][ast] for more.
///
/// Ylem input can be either one of the following:
/// - a Ylem item, which is a [Ylem source unit][ylm-item] which generates one or more Rust items,
/// - a [Ylem type name][ylm-types], which simply expands to the corresponding Rust type.
///
/// [ylm-item]: https://docs.soliditylang.org/en/latest/grammar.html#a4.YlemParser.sourceUnit
/// [ylm-types]: https://docs.soliditylang.org/en/latest/types.html
///
/// ### Attributes
///
/// Inner attributes (`#![...]`) are parsed at the top of the input, just like a
/// Rust module. These can only be `sol` attributes, and they will apply to the
/// entire input.
///
/// Outer attributes (`#[...]`) are parsed as part of each individual item, like
/// structs, enums, etc. These can be any Rust attribute, and they will be added
/// to every Rust item generated from the Ylem item.
///
/// This macro provides the `sol` attribute, which can be used to customize the
/// generated code. Note that unused attributes are currently silently ignored,
/// but this may change in the future.
///
/// List of all `#[ylm(...)]` supported attributes:
/// - `rpc [ = <bool = false>]` (contracts and alike only): generates a structs with methods to
///   construct `eth_call`s to an on-chain contract through Core JSON RPC, similar to the
///   default behavior of [`abigen`]. This makes use of the [`base-contract`](https://github.com/core-coin/atoms-rs)
///   crate.
///
///   N.B: at the time of writing, the `base-contract` crate is not yet released on `crates.io`,
///   and its API is completely unstable and subject to change, so this feature is not yet
///   recommended for use.
///
///   Generates:
///   - `struct {name}Instance<P: Provider> { ... }`
///     - `pub fn new(...) -> {name}Instance<P>` + getters and setters
///     - `pub fn call_builder<C: YlmCall>(&self, call: &C) -> YlmCallBuilder<P, C>`, as a generic
///       way to call any function of the contract, even if not generated by the macro; prefer the
///       other methods when possible
///     - `pub fn <functionName>(&self, <parameters>...) -> CallBuilder<P, functionReturn>` for each
///       function in the contract
///     - `pub fn <eventName>_filter(&self) -> Event<P, eventName>` for each event in the contract
///   - `pub fn new ...`, same as above just as a free function in the contract module
/// - `abi [ = <bool = false>]`: generates functions which return the dynamic ABI representation
///   (provided by [`base_json_abi`](https://docs.rs/base-json-abi)) of all the generated items.
///   Requires the `"json"` feature. For:
///   - contracts: generates an `abi` module nested inside of the contract module, which contains:
///     - `pub fn contract() -> JsonAbi`,
///     - `pub fn constructor() -> Option<Constructor>`
///     - `pub fn fallback() -> Option<Fallback>`
///     - `pub fn receive() -> Option<Receive>`
///     - `pub fn functions() -> BTreeMap<String, Vec<Function>>`
///     - `pub fn events() -> BTreeMap<String, Vec<Event>>`
///     - `pub fn errors() -> BTreeMap<String, Vec<Error>>`
///   - items: generates implementations of the `SolAbiExt` trait, alongside the existing
///     [`base-ylm-types`] traits
/// - `base_ylm_types = <path = ::base_ylm_types>` (inner attribute only): specifies the path to the
///   required dependency [`base-ylm-types`].
/// - `base_contract = <path = ::base_contract>` (inner attribute only): specifies the path to the
///   optional dependency [`base-contract`]. This is only used in combination with the `rpc`
///   attribute.
/// - `all_derives [ = <bool = false>]`: adds all possible `#[derive(...)]` attributes to all
///   generated types. May significantly increase compile times due to all the extra generated code.
///   This is the default behavior of [`abigen`]
/// - `extra_methods [ = <bool = false>]`: adds extra implementations and methods to all applicable
///   generated types, such as `From` impls and `as_<variant>` methods. May significantly increase
///   compile times due to all the extra generated code. This is the default behavior of [`abigen`]
/// - `docs [ = <bool = true>]`: adds doc comments to all generated types. This is the default
///   behavior of [`abigen`]
/// - `bytecode = <hex string literal>` (contract-like only): specifies the creation/init bytecode
///   of a contract. This will emit a `static` item with the specified bytes.
/// - `deployed_bytecode = <hex string literal>` (contract-like only): specifies the deployed
///   bytecode of a contract. This will emit a `static` item with the specified bytes.
/// - `type_check = <string literal>` (UDVT only): specifies a function to be used to check an User
///   Defined Type.
///
/// ### Structs and enums
///
/// Structs and enums generate their corresponding Rust types. Enums are
/// additionally annotated with `#[repr(u8)]`, and as such can have a maximum of
/// 256 variants.
/// ```ignore
#[cfg_attr(doc, doc = include_str!("../../ylm-types/tests/doctests/structs.rs"))]
/// ```
/// 
/// ### UDVT and type aliases
///
/// User defined value types (UDVT) generate a tuple struct with the type as
/// its only field, and type aliases simply expand to the corresponding Rust
/// type.
/// ```ignore
#[cfg_attr(doc, doc = include_str!("../../ylm-types/tests/doctests//types.rs"))]
/// ```
/// 
/// ### State variables
///
/// Public and external state variables will generate a getter function just like in Ylem.
///
/// See the [functions](#functions-and-errors) and [contracts](#contractsinterfaces)
/// sections for more information.
///
/// ### Functions and errors
///
/// Functions generate two structs that implement `YlmCall`: `<name>Call` for
/// the function arguments, and `<name>Return` for the return values.
///
/// In the case of overloaded functions, an underscore and the index of the
/// function will be appended to `<name>` (like `foo_0`, `foo_1`...) for
/// disambiguation, but the signature will remain the same.
///
/// E.g. if there are two functions named `foo`, the generated types will be
/// `foo_0Call` and `foo_1Call`, each of which will implement `YlmCall`
/// with their respective signatures.
/// ```ignore
#[cfg_attr(doc, doc = include_str!("../../ylm-types/tests/doctests//function_like.rs"))]
/// ```
/// 
/// ### Events
///
/// Events generate a struct that implements `YlmEvent`.
///
/// Note that events have special encoding rules in Ylem. For example,
/// `string indexed` will be encoded in the topics as its `bytes32` Keccak-256
/// hash, and as such the generated field for this argument will be `bytes32`,
/// and not `string`.
/// ```ignore
#[cfg_attr(doc, doc = include_str!("../../ylm-types/tests/doctests//events.rs"))]
/// ```
/// 
/// ### Contracts/interfaces
///
/// Contracts generate a module with the same name, which contains all the items.
/// This module will also contain 3 container enums which implement `YlmInterface`, one for each:
/// - functions: `<contract_name>Calls`
/// - errors: `<contract_name>Errors`
/// - events: `<contract_name>Events`
/// Note that by default only ABI encoding are generated. In order to generate bindings for RPC
/// calls, you must enable the `#[ylm(rpc)]` attribute.
/// ```ignore
#[cfg_attr(doc, doc = include_str!("../../ylm-types/tests/doctests//contracts.rs"))]
/// ```
/// 
/// ## JSON ABI
///
/// Contracts can also be generated from ABI JSON strings and files, similar to
/// the [ethers-rs `abigen!` macro][abigen].
///
/// JSON objects containing the `abi`, `evm`, `bytecode`, `deployedBytecode`,
/// and similar keys are also supported.
///
/// Note that only valid JSON is supported, and not the human-readable ABI
/// format, also used by [`abigen!`][abigen]. This should instead be easily converted to
/// [normal Ylem input](#solidity).
///
/// Prefer using [Ylem input](#solidity) when possible, as the JSON ABI
/// format omits some information which is useful to this macro, such as enum
/// variants and visibility modifiers on functions.
///
/// [abigen]: https://docs.rs/ethers/latest/ethers/contract/macro.abigen.html
/// [`abigen`]: https://docs.rs/ethers/latest/ethers/contract/macro.abigen.html
/// ```ignore
#[cfg_attr(doc, doc = include_str!("../../ylm-types/tests/doctests//json.rs"))]
/// ```
#[proc_macro]
#[proc_macro_error]
pub fn ylm(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as base_ylm_macro_input::YlmInput);

    YlmMacroExpander.expand(&input).unwrap_or_else(syn::Error::into_compile_error).into()
}

struct YlmMacroExpander;

impl YlmInputExpander for YlmMacroExpander {
    fn expand(&mut self, input: &YlmInput) -> syn::Result<proc_macro2::TokenStream> {
        let input = input.clone();

        #[cfg(feature = "json")]
        let is_json = matches!(input.kind, YlmInputKind::Json { .. });
        #[cfg(not(feature = "json"))]
        let is_json = false;

        // Convert JSON input to Ylem input
        #[cfg(feature = "json")]
        let input = input.normalize_json()?;

        let YlmInput { attrs, path, kind } = input;
        let include = path.map(|p| {
            let p = p.to_str().unwrap();
            quote! { const _: &'static [u8] = ::core::include_bytes!(#p); }
        });

        let tokens = match kind {
            YlmInputKind::Sol(mut file) => {
                // Attributes have already been added to the inner contract generated in
                // `normalize_json`.
                if !is_json {
                    file.attrs.extend(attrs);
                }

                crate::expand::expand(file)
            }
            YlmInputKind::Type(ty) => {
                let (ylm_attrs, rest) = YlmAttrs::parse(&attrs)?;
                if !rest.is_empty() {
                    return Err(syn::Error::new_spanned(
                        rest.first().unwrap(),
                        "only `#[ylm]` attributes are allowed here",
                    ));
                }

                let mut crates = crate::expand::ExternCrates::default();
                crates.fill(&ylm_attrs);
                Ok(crate::expand::expand_type(&ty, &crates))
            }
            #[cfg(feature = "json")]
            YlmInputKind::Json(_, _) => unreachable!("input already normalized"),
        }?;

        Ok(quote! {
            #include
            #tokens
        })
    }
}
